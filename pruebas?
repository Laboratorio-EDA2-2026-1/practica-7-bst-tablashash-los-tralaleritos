import math
class Nodo:
    def __init__(self, caracter: str, frecuencia: int = 1):
        self.caracter = caracter
        self.frecuencia = frecuencia
        self.izquierda = None
        self.derecha = None

# Variables globales a usar:
M = 31
mensaje_encriptado ="(/-.-4%(+28.%#+2/($(6(#(3(8%.-/2(+(/(6.("
A = 0.61803

# Analisis de la Frecuencia utilizando BST:
class BSTFrecuencia:
    # Arbol Binario de Búsqueda para almacenar la frecuencia de caracteres
    def __init__(self):
        self.raiz = None

    def _insertar_recursivo(self, nodo_actual: Nodo, caracter: str) -> Nodo:
        if nodo_actual is None:
            return Nodo(caracter)

        if caracter == nodo_actual.caracter:
            nodo_actual.frecuencia += 1
            return nodo_actual
        elif caracter < nodo_actual.caracter:
            nodo_actual.izquierda = self._insertar_recursivo(nodo_actual.izquierda, caracter)
        else: # caracter > nodo_actual.caracter
            nodo_actual.derecha = self._insertar_recursivo(nodo_actual.derecha, caracter)
        
        return nodo_actual

    def insertar(self, caracter: str):
        self.raiz = self._insertar_recursivo(self.raiz, caracter)

    def construir_desde_cadena(self, cadena: str):
        for caracter in cadena:
            self.insertar(caracter)

    # --- IMPRIMIR ORDENADO POR CARACTER (NORMAL: RECORRIDO INORDEN) ---
    def _inorden_recursivo(self, nodo_actual: Nodo):
        if nodo_actual is not None:
            self._inorden_recursivo(nodo_actual.izquierda)
            print(f"'{nodo_actual.caracter}': {nodo_actual.frecuencia}")
            self._inorden_recursivo(nodo_actual.derecha)

    def imprimir_frecuencias(self):
        print("\n--- 1. Frecuencias (Orden Alfabético/ASCII - Inorden) ---")
        self._inorden_recursivo(self.raiz)

    # --- IMPRIMIR ORDENADO POR FRECUENCIA (MAYOR A MENOR) ---
    def _recolectar_datos(self, nodo_actual: Nodo, lista_datos: list):
        if nodo_actual is not None:
            lista_datos.append((nodo_actual.caracter, nodo_actual.frecuencia))
            self._recolectar_datos(nodo_actual.izquierda, lista_datos)
            self._recolectar_datos(nodo_actual.derecha, lista_datos)

    def obtener_frecuencias_ordenadas(self):
        datos_totales = []
        self._recolectar_datos(self.raiz, datos_totales)
        
        # Ordenar por frecuencia (elemento [1] de la tupla) de forma descendente
        datos_ordenados = sorted(datos_totales, key=lambda x: x[1], reverse=True)
        
        print("\n--- 2. Frecuencias (Orden Mayor a Menor Frecuencia) ---")
        for caracter, frecuencia in datos_ordenados:
            print(f"'{caracter}': {frecuencia}")
    
# ----------------------------------------------------------------------
# --- EJECUCIÓN ---
# ----------------------------------------------------------------------

# 1. Crear la instancia del BST
bst_frecuencia = BSTFrecuencia()
# 2. Construir el BST a partir de la cadena
bst_frecuencia.construir_desde_cadena(mensaje_encriptado)

"""
Tenemos 12 caracteres unicos mientras que la lista proporcionada tiene 14, lo que sugiere hay colisiones en las letras e
'(': 11
'/': 4
'.': 4
'%': 3
'-': 3
'+': 3
'2': 3
'#': 2
'8': 2
'6': 2
'$': 1
'4': 1
'3': 1
Total = 40

Dados por el profe
e: 11(10), en realidad el puso 10, tomaremos como 11 ya que se requiere sean 40 caracteres en total, pero el '(' sale 11 veces, asi que partire del supuesto de que '(' es la letra e; ASCII: 101
t: 4, queremos creer que esto comprende a el caracter '/'
a: 4, queremos creer esto comprende al caracter '.'
o: 3
u: 3
r: 3
s: 2
c: 2
n: 2
d: 2
l: 1
q: 1
b: 1
j: 1
Total: 39

Partiremos de que la que sale 10 veces, en realidad es 11, ya que son los datos arrojados, diciendo asi que "e" aparece 11 veces en el mensaje encriptado
"""

#Definiendo el mapeo de dispersion
def funcion_division_dispersa(caracter_l):
    k = ord(caracter_l)
    k_por_A = k * A
    
    parte_fraccionaria = k_por_A % 1
    
    indice_disperso = math.floor(M * parte_fraccionaria)
    
    indice_final = indice_disperso + 32
    
    return indice_final
    
    
    
#Definiendo mapeo de modulo
def funcion_modulo(l):
    k = ord(l) #Podria ser un 40, significando (
    letra = (k % 31) + 32
    return letra
    


#Partiendo del supuesto de que los caracteres que no son un numero, utilizan la funcion de division:
sapito = funcion_division_dispersa('q')
sapito2 = funcion_modulo('q')
print(chr(sapito))
print(chr(sapito2))

mensaje_desencriptado ="e/-.-4be+28.%#+2/e$e6e#e3e8%.-/2(+e/e6.e"

